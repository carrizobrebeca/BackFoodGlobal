"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseLine = void 0;
const lodash_1 = __importDefault(require("lodash"));
const line_1 = require("./line");
const parameter_1 = require("./parameter");
const FULL_LINE_PATTERN = /^\/\*(\[\d{4}-[\s\d]{1}\d-[\s\d]{1}\d\s[\s\d]{1}\d:[\s\d]{1}\d:[\s\d]{1}\d\([\s\d]{3}\)\])\*\/\s(.*);$/;
const PURE_LINE_PATTERN = /^(Jrn[a-zA-Z]{3}).([a-zA-Z]+)\((.*)\)/;
const PARAMETER_SPLITTER = /,\s?/;
const PARAMETERS_PATTERN = /^(.*)(\/\*(.*)\*\/)/;
function isString(parameter) {
    return parameter.startsWith("\"") && parameter.endsWith("\"");
}
function isStringBegin(parameter) {
    return parameter.startsWith("\"") && !parameter.endsWith("\"");
}
function isStringEnd(parameter) {
    return !parameter.startsWith("\"") && parameter.endsWith("\"");
}
/**
 * Parse parameter
 * @param parameterLiteral parameter value literal
 * @param prefix prefix string in front of parameter value literal
 * @returns parsed parameter
 */
function parseParameter(parameterLiteral, prefix = "") {
    let valueLiteral = parameterLiteral;
    let comment = "";
    if (parameterLiteral.endsWith("*/")) {
        const matchResult = parameterLiteral.match(PARAMETERS_PATTERN);
        if (!lodash_1.default.isNull(matchResult)) {
            if (!lodash_1.default.isNull(matchResult[1])) {
                valueLiteral = matchResult[1];
            }
            if (!lodash_1.default.isNull(matchResult[3])) {
                comment = matchResult[3];
            }
        }
    }
    return new parameter_1.Parameter(valueLiteral, prefix, comment);
}
/**
 * Parse parameter literal and return parameter list
 * @param parameterLiteral a string representing parameter literal
 * @returns parameters
 */
function parseParameters(parameterLiteral) {
    let segments = parameterLiteral.split(PARAMETER_SPLITTER);
    let groups = [];
    for (let i = 0; i < segments.length; ++i) {
        let segment = segments[i];
        if (isStringBegin(segment)) {
            let temp = [];
            for (; i < segments.length; ++i) {
                segment = segments[i];
                temp.push(segment);
                if (isStringEnd(segment)) {
                    break;
                }
            }
            groups.push(temp);
        }
        else {
            groups.push([segment]);
        }
    }
    segments = groups.map((group) => {
        return 1 === group.length ? group[0] : group.join(",");
    });
    if (0 === segments.length) {
        return [];
    }
    let parameters = [parseParameter(segments[0])];
    let len = segments[0].length;
    for (let i = 1; i < segments.length; ++i) {
        ++len;
        let prefix = "";
        if (parameterLiteral[len] === " ") {
            ++len;
            prefix = " ";
        }
        parameters.push(parseParameter(segments[i], prefix));
        len += segments[i].length;
    }
    return parameters;
}
/**
 * Parse given line literal and return parsed line
 * @param line a string representing line literal
 * @returns parsed line, including parameterized line and raw line
 */
function parseLine(line) {
    let prefix = "";
    let pure = line;
    if (line.startsWith("/*")) {
        const matchResult = line.match(FULL_LINE_PATTERN);
        if (!lodash_1.default.isNull(matchResult)) {
            prefix = matchResult[1];
            pure = matchResult[2];
        }
    }
    if (!pure.startsWith("//")) {
        const matchResult = pure.match(PURE_LINE_PATTERN);
        if (!lodash_1.default.isNull(matchResult)) {
            const mod = matchResult[1];
            const lineType = matchResult[2];
            const parameterLiteral = matchResult[3];
            const parameters = parseParameters(parameterLiteral);
            return new line_1.ParameterizedLine(mod, lineType, parameters, prefix);
        }
    }
    return new line_1.RawLine(line);
}
exports.parseLine = parseLine;
